{
  "projectName": "SOA Chat Application",
  "description": "This is a nestjs backend api that is part of a service-oriented architecture chat application featuring real-time chat, AI-powered interactions, and systematic documentation of development and debugging processes.",
  "rules": {
    "developmentGuidelines": {
      "codeQualityPrinciples": {
        "description": "Core principles that must be followed in all code development",
        "principles": [
          {
            "name": "DRY (Don't Repeat Yourself)",
            "description": "Code must not contain duplicated logic or implementations",
            "requirements": [
              "Extract repeated code into reusable functions or classes",
              "Use shared utilities for common operations",
              "Implement proper inheritance and composition patterns",
              "Create shared interfaces and types for repeated structures"
            ]
          },
          {
            "name": "SOLID Principles",
            "description": "All code must adhere to SOLID principles",
            "principles": [
              {
                "name": "Single Responsibility",
                "description": "Each class/module should have only one reason to change"
              },
              {
                "name": "Open/Closed",
                "description": "Software entities should be open for extension but closed for modification"
              },
              {
                "name": "Liskov Substitution",
                "description": "Derived classes must be substitutable for their base classes"
              },
              {
                "name": "Interface Segregation",
                "description": "Clients should not be forced to depend on interfaces they don't use"
              },
              {
                "name": "Dependency Inversion",
                "description": "Depend on abstractions, not concretions"
              }
            ]
          },
          {
            "name": "KISS (Keep It Simple, Stupid)",
            "description": "Code should be as simple as possible, avoiding unnecessary complexity",
            "requirements": [
              "Write straightforward, easy-to-understand code",
              "Avoid over-engineering solutions",
              "Break complex problems into smaller, manageable pieces",
              "Use clear, descriptive naming conventions"
            ]
          },
          {
            "name": "YAGNI (You Aren't Gonna Need It)",
            "description": "Only implement features that are needed now, not what might be needed in the future",
            "requirements": [
              "Avoid speculative programming",
              "Focus on current requirements",
              "Refactor when new requirements arise",
              "Don't build features 'just in case'"
            ]
          },
          {
            "name": "Fail Fast",
            "description": "Detect and report failures as soon as possible in the development cycle",
            "requirements": [
              "Implement comprehensive error handling",
              "Use strong typing and validation",
              "Add meaningful error messages",
              "Validate inputs early in the process"
            ]
          },
          {
            "name": "Clean Code",
            "description": "Code should be readable, maintainable, and testable",
            "requirements": [
              "Use meaningful variable and function names",
              "Keep functions small and focused",
              "Write self-documenting code",
              "Include proper comments for complex logic",
              "Follow consistent formatting and style"
            ]
          },
          {
            "name": "Separation of Concerns",
            "description": "Different aspects of the application should be separated into distinct sections",
            "requirements": [
              "Separate business logic from presentation logic",
              "Use proper layering (controllers, services, repositories)",
              "Keep WebSocket events separate from HTTP endpoints",
              "Maintain clear boundaries between different modules"
            ]
          },
          {
            "name": "Defensive Programming",
            "description": "Anticipate and handle potential errors and edge cases",
            "requirements": [
              "Validate all inputs and parameters",
              "Handle all possible error scenarios",
              "Implement proper type checking",
              "Add logging for debugging and monitoring",
              "Use try-catch blocks appropriately"
            ]
          }
        ],
        "validation": {
          "required": true,
          "onGeneration": "Must verify code follows DRY and SOLID principles",
          "onModification": "Must ensure changes maintain DRY and SOLID compliance"
        }
      },
      "antiPatterns": {
        "description": "These patterns are strictly forbidden and must never be generated",
        "forbidden": [
          {
            "pattern": "Multiple Authentication Points",
            "description": "Authentication must only happen in WsGuard and BaseGateway",
            "example": "Checking auth tokens in multiple gateways or services",
            "prevention": "Always use WsGuard and BaseGateway authentication"
          },
          {
            "pattern": "Direct Socket Access Outside Gateways",
            "description": "Socket operations must only occur in gateway classes",
            "example": "Accessing socket instance in services",
            "prevention": "Use EventService for all socket communications"
          },
          {
            "pattern": "Mixing HTTP and Socket State Changes",
            "description": "Keep HTTP state changes separate from WebSocket updates",
            "example": "Emitting socket events from HTTP controllers",
            "prevention": "Use proper event emission through EventService"
          },
          {
            "pattern": "Global State in Socket Instances",
            "description": "No storing state directly on socket instances",
            "example": "socket.data = { globalState: {} }",
            "prevention": "Use proper state management services"
          },
          {
            "pattern": "Lack of Error Handling",
            "description": "All socket operations must have proper error handling",
            "example": "Missing try-catch blocks in socket handlers",
            "prevention": "Always implement comprehensive error handling"
          },
          {
            "pattern": "Synchronous Blocking Operations",
            "description": "No blocking operations in socket handlers",
            "example": "Using while loops or synchronous operations",
            "prevention": "Use async/await and proper Promise handling"
          }
        ],
        "validation": {
          "required": true,
          "onGeneration": "Must verify no anti-patterns are present in generated code",
          "onModification": "Must verify changes don't introduce anti-patterns"
        }
      }
    }
  }
}


DO NOT ADD THINGS TO BRAINLIFT.MD UNLESS I EXPLICITLY SAY SO